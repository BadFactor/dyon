_seps: "(){}[],.:;=<>*·+-/%^?|&∧∨!¬∑∃∀\n"

200 multi_line_comment = ["/*" ..."*/"? .r?({
    [!"*/" "*" ..."*/"?] [multi_line_comment ..."*/"?] ["/" ..."*/"?]
}) "*/"]
201 comment = {multi_line_comment ["//" ..."\n"?]}
202 w = .r!({.w! comment})

0 fn = {
    ["fn" .w! .."("!:"name" ?w "(" ?w args ?w ")" ?w {
        ["->":"returns" ?w ?type:"ret_type"]
        !"->":!"returns"
    } ?w block:"block"]
    [.."("!:"name" ?w "(" ?w args ?w ")" ?w "=" ?w expr:"expr"]
}
1 args = .s?.(, arg:"arg")
2 arg = [?"mut":"mut" ?w .._seps!:"name" ?[?w ":" ?w
         ?["'" ?w .._seps!:"lifetime"] ?w ?type:"type"]]
// Support both multi-line expressions and single line.
3 block = ["{" ?w {.l([?w expr:"expr" ?w]) [?w expr:"expr"]} ?w "}"]
4 expr = [{
    object:"object"
    arr
    ["return" .w! expr:"return"]
    for_n:"for_n"
    for:"for"
    loop:"loop"
    if:"if"
    break:"break"
    continue:"continue"
    block:"block"
    assign:"assign"
    compare:"compare"
    ["return":"return_void"]
    add:"add"
    short_loops
    items
} try]
// Interprets "return" as variable, does not expect loops or assignment.
5 arg_expr = {
    ["mut":"mut" ?w item:"item"]
    [{
        object:"object"
        arr
        if:"if"
        block:"block"
        compare:"compare"
        add:"add"
        short_loops
        items
    } try]
}
6 lexpr = [{
    object:"object"
    arr
    short_loops
    block:"block"
    items
} try]
7 object = ["{" ?w .s?.(, key_value:"key_value") ?w "}"]
8 array = ["[" ?w .s?.(, expr:"array_item") ?w "]"]
9 array_fill = ["[" ?w expr:"fill" ?w ";" ?w expr:"n" ?w "]"]
10 key_value = [.._seps!:"key" ?w ":" ?w expr:"val"]
11 num = .$_:"num"
12 vec4 = ["(" ?w expr:"x" , expr:"y" ?[, expr:"z" ?[, expr:"w"]] ?, ?w ")"]
13 color = ["#" .._seps!:"color"]
14 text = .t?:"text"
15 bool = {"true":"bool" "false":!"bool"}
16 unop = {
    [{"!":"!" "¬":"!" "-":"-"} ?w lexpr:"expr"]
    ["|":"norm" ?w expr:"expr" ?w "|"]
}
17 item = [.._seps!:"name" ?[?w "?":"try_item"] ?item_extra:"item_extra"]
18 item_extra = .r!([{
           [?w "[" ?w {.t?:"id" .$_:"id" expr:"id"} ?w "]"]
           [?w "." ?w .._seps!:"id"]} ?[?w "?":"try_id"]])
19 for = [label "for" .w!
    expr:"init" ?w ";" ?w
    expr:"cond" ?w ";" ?w
    expr:"step" ?w block:"block"]
20 for_n = [label "for" short_body]
21 loop = [label "loop" .w!  block:"block"]
22 break = ["break" ?w ?["'" .._seps!:"label"]]
23 continue = ["continue" ?w ?["'" .._seps!:"label"]]
24 if = ["if" .w! expr:"cond" ?w block:"true_block"
         .r?([?w "else" w "if" ?w expr:"else_if_cond" ?w block:"else_if_block"])
         ?[?w "else" ?w block:"else_block"]]
25 call = [.._seps!:"name" wn "(" .s?.(, arg_expr:"call_arg") ?w ")"]
26 named_call = [.._seps!:"word" wn "(" ?w
    .s?.(, [.._seps!:"word" ?w ":" ?w arg_expr:"call_arg" ?w]) ")"]
27 go = ["go" ?w {call:"call" named_call:"named_call"}]
28 assign = [lexpr:"left" ?w assign_op ?w expr:"right"]
29 assign_op = {":=":":=" "=":"=" "+=":"+=" "-=":"-=" "*=":"*=" "/=":"/=" "%=":"%="}
30 compare = [lexpr:"left" ?w compare_op ?w expr:"right"]
31 compare_op = {"==":"==" "!=":"!=" "¬=":"!=" "<=":"<=" "<":"<" ">=":">=" ">":">"}

40 label = ?["'" .._seps!:"label" ?w ":" ?w]
41 short_body = [.w! .s!.(, [.._seps!:"name" ?w
    ?{
        ["[" ?w expr:"start" , expr:"end" ?w ")"]
        [!"{" expr:"end"]
    }]) ?w block:"block"]
42 try = ?[?w "?":"try"]
43 , = [?w "," ?w]
44 arr = {array:"array" array_fill:"array_fill"}
45 items = {vec4:"vec4" ["(" ?w expr ?w ")"] unop:"unop"
            text go:"go" call:"call" named_call:"named_call"
            num bool color item:"item"}
// Allow whitespace, but no new line.
46 wn = .r?({" " "\t" "\r"})

50 short_loops = {sum:"sum" sum_vec4:"sum_vec4" min:"min" max:"max" sift:"sift"
    any:"any" all:"all"}
51 sum = [label {"sum" "∑"} short_body]
52 min = [label "min" short_body]
52 max = [label "max" short_body]
53 sift = [label "sift" short_body]
54 any = [label {"any" "∃"} short_body]
55 all = [label {"all" "∀"} short_body]
56 sum_vec4 = [label {"sum_vec4" "∑vec4"} short_body]

60 type = {
    "bool":"bool"
    "f64":"f64"
    "str":"str"
    "vec4":"vec4"
    ["opt" ?w "[" ?w type:"opt" ?w "]"]
    "opt":"opt_any"
    ["res" ?w "[" ?w type:"res" ?w "]"]
    "res":"res_any"
    "[]":"arr_any"
    ["[" ?w type:"arr" ?w "]"]
    "{}":"obj_any"
    ["thr" ?w "[" ?w type:"thr" ?w "]"]
    "thr":"thr_any"
}

101 + = [?w {"+":"+" "||":"+" "∨":"+" "or":"+"} ?w]
102 - = [?w "-":"-" ?w]
// Allow whitespace before multiplication sign, but no new line.
// This prevents `x` on a new line from being interpreted as multiplication sign.
103 * = [wn {
    "*.":"*." "·":"*."
    "x":"x" "⨯":"x"
    "*":"*" "&&":"*" "∧":"*" "and":"*"
} ?w]
104 / = [?w "/":"/" ?w]
105 % = [?w "%":"%" ?w]
107 pow = [lexpr:"base" ?w "^" ?w lexpr:"exp"]
108 mul = .s!({* / %} {pow:"pow" lexpr:"val"})
109 add = .s!({+ -} mul:"mul")

1000 document = .l({[.w? fn:"fn"] comment})

_seps: "(){}[],.:;=<>*+-/%^"

200 multi_line_comment = ["/*" ..."*/"? .r?({
    [!"*/" "*" ..."*/"?]
    [multi_line_comment ..."*/"?]
    ["/" ..."*/"?]
}) "*/"]
201 comment = {multi_line_comment ["//" ..."\n"?]}
// 202 w = .r!({.w! comment})
202 w = .r!({.w! comment})

0 fn = ["fn" .w! .."("!:"name" ?w "(" args ")" ?w ?"->":"returns" ?w block:"block"]
1 args = .s?.([?w "," ?w] arg:"arg")
2 arg = [.._seps!:"name" ?[?w ":" ?w "'" ?w .._seps!:"lifetime"]]
// Support both multi-line expressions and single line.
3 block = ["{" ?w {.l([?w expr:"expr" ?w]) [?w expr:"expr"]} ?w "}"]
4 expr = {
    object:"object"
    array:"array"
    ["return" .w! expr:"return"]
    for:"for"
    loop:"loop"
    if:"if"
    break:"break"
    continue:"continue"
    block:"block"
    assign:"assign"
    compare:"compare"
    ["return":"return_void"]
    add:"add"
    named_call:"named_call"
    ["(" ?w expr ?w ")"]
    unop:"unop"
    call:"call"
    text
    num
    bool
    item:"item"
}
// Interprets "return" as variable, does not expect loops or assignment.
5 arg_expr = {
    object:"object"
    array:"array"
    if:"if"
    block:"block"
    compare:"compare"
    add:"add"
    named_call:"named_call"
    ["(" ?w expr ?w ")"]
    unop:"unop"
    call:"call"
    text
    num
    bool
    item:"item"
}
6 lexpr = {
    object:"object"
    array:"array"
    block:"block"
    named_call:"named_call"
    ["(" ?w expr ?w ")"]
    unop:"unop"
    call:"call"
    text
    num
    bool
    item:"item"
}
7 object = ["{" ?w .s?.([?w "," ?w] key_value:"key_value") ?w "}"]
8 array = ["[" ?w .s?.([?w "," ?w] expr:"array_item") ?w "]"]
9 key_value = [.._seps!:"key" ?w ":" ?w expr:"val"]
10 num = .$_:"num"
11 text = .t?:"text"
12 bool = {"true":"bool" "false":!"bool"}
13 unop = ["!":"!" ?w lexpr:"expr"]
14 item = [.._seps!:"name" .r?({
    [?w "[" ?w {.t?:"id" .$_:"id" expr:"id"} ?w "]"]
    [?w "." ?w .._seps!:"id"]
})]
15 for = [?["'" .._seps!:"label" ?w ":" ?w] "for" .w!
    expr:"init" ?w ";" ?w
    expr:"cond" ?w ";" ?w
    expr:"step" ?w block:"block"]
16 loop = [?["'" .._seps!:"label" ?w ":" ?w] "loop" .w!  block:"block"]
17 break = ["break" ?w ?["'" .._seps!:"label"]]
18 continue = ["continue" ?w ?["'" .._seps!:"label"]]
19 if = [
    "if" .w! expr:"cond" ?w block:"true_block"
    ?[?w "else" ?w block:"else_block"]
]
20 call = [.._seps!:"name" ?w "(" .s?.([?w "," ?w] arg_expr:"arg") ?w ")"]
21 named_call = [.._seps!:"word" ?w "(" ?w
    .s?.([?w "," ?w] [.._seps!:"word" ?w ":" ?w arg_expr:"arg" ?w]) ")"]
22 assign = [lexpr:"left" ?w assign_op ?w expr:"right"]
23 assign_op = {
    ":=":":="
    "=":"="
    "+=":"+="
    "-=":"-="
    "*=":"*="
    "/=":"/="
    "%=":"%="
}
24 compare = [lexpr:"left" ?w compare_op ?w expr:"right"]
25 compare_op = {
    "==":"=="
    "!=":"!="
    "<=":"<="
    "<":"<"
    ">=":">="
    ">":">"
}

101 + = [?w {"+":"+" "||":"+"} ?w]
102 - = [?w "-":"-" ?w]
103 * = [?w {"*":"*" "&&":"*"} ?w]
104 / = [?w "/":"/" ?w]
105 % = [?w "%":"%" ?w]
107 pow = [lexpr:"base" ?w "^" ?w lexpr:"exp"]
108 mul = .s!({* / %} {
    pow:"pow"
    lexpr:"val"
})
109 add = .s!({+ -} {
    mul:"mul"
})

1000 document = .l({fn:"fn" comment})
